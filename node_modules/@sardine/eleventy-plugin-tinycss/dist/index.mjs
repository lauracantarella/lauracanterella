import {parseHTML as $jAp8N$parseHTML} from "linkedom";
import {PurgeCSS as $jAp8N$PurgeCSS} from "purgecss";
import $jAp8N$browserslist from "browserslist";
import {browserslistToTargets as $jAp8N$browserslistToTargets, transform as $jAp8N$transform} from "@parcel/css";
import {promises as $jAp8N$promises} from "fs";

var $fb56d782b5508ff5$exports = {};





async function $e35e0750779b35d5$export$8e388a857ed0c062(rawCss, html, options) {
    try {
        var ref;
        const userPurgeCSSOptions = (ref = options === null || options === void 0 ? void 0 : options.purgeCSS) !== null && ref !== void 0 ? ref : {
        };
        var ref1;
        const targets = $jAp8N$browserslistToTargets($jAp8N$browserslist((ref1 = options === null || options === void 0 ? void 0 : options.browserslists) !== null && ref1 !== void 0 ? ref1 : null));
        const { code: code  } = $jAp8N$transform({
            filename: 'style.css',
            code: Buffer.from(rawCss),
            minify: true,
            targets: targets
        });
        const purgeCSSOptions = {
            content: [
                {
                    raw: html,
                    extension: 'html'
                }, 
            ],
            css: [
                {
                    raw: code.toString()
                }
            ]
        };
        Object.assign(purgeCSSOptions, userPurgeCSSOptions);
        const [{ css: css  }] = await new $jAp8N$PurgeCSS().purge(purgeCSSOptions);
        return css;
    } catch (error) {
        console.error(error);
        throw error;
    }
}
function $e35e0750779b35d5$export$eeda1f886239af9(link, root = '_site') {
    const src = root + link.href;
    return $jAp8N$promises.readFile(src, {
        encoding: 'utf-8'
    });
}


const $0bff4bb3e9a7894a$export$45dcf71843d1d76c = async (html, options)=>{
    const { document: document  } = $jAp8N$parseHTML(html);
    const styles = [
        ...document.querySelectorAll('style')
    ];
    const links = [
        ...document.querySelectorAll('link[rel=stylesheet]')
    ];
    if (links.length > 0 || styles.length > 0) {
        let css = '';
        if (links.length > 0) {
            const externalCSS = await Promise.all(links.map((link)=>{
                if (/^(https?\:\/\/|\/\/)/i.test(link.href)) return;
                return $e35e0750779b35d5$export$eeda1f886239af9(link, options === null || options === void 0 ? void 0 : options.output);
            }));
            css = externalCSS.join('');
            links.map((link)=>{
                if (/^(https?\:\/\/|\/\/)/i.test(link.href)) return;
                return link.remove();
            });
        }
        if (styles.length > 0) for (const style of styles){
            css = css + style.textContent;
            style.remove();
        }
        const minicss = await $e35e0750779b35d5$export$8e388a857ed0c062(css, html, options);
        const inline = document.createElement('style');
        const head = document.getElementsByTagName('head')[0];
        const inlinStyle = document.createTextNode(minicss);
        inline.appendChild(inlinStyle);
        head.appendChild(inline);
        html = document.toString();
    }
    return html;
};


$fb56d782b5508ff5$exports = (eleventyConfig, options)=>{
    eleventyConfig.namespace('tinyCSS', ()=>{
        eleventyConfig.addTransform('tinyCSS', async (content, outputPath)=>{
            try {
                if (outputPath && outputPath.endsWith('.html')) content = await $0bff4bb3e9a7894a$export$45dcf71843d1d76c(content, options);
            } catch (error) {
                console.error(error);
            }
            return content;
        });
    });
};


export {$fb56d782b5508ff5$exports as default};
//# sourceMappingURL=index.mjs.map
